


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > KotlinUtilsKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">team.duckie.quackquack.common.lint.util</a>
</div>

<h1>Coverage Summary for Class: KotlinUtilsKt (team.duckie.quackquack.common.lint.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">KotlinUtilsKt</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (14/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.5%
  </span>
  <span class="absValue">
    (69/78)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Designed and developed by 2022 SungbinLand, Team Duckie
&nbsp; *
&nbsp; * Licensed under the MIT.
&nbsp; * Please see full license: https://github.com/sungbinland/quack-quack/blob/main/LICENSE
&nbsp; */
&nbsp;
&nbsp;// TAKEN FROM: https://github.com/androidx/androidx/tree/androidx-main/compose/lint/common/src/main/java/androidx/compose/lint
&nbsp;
&nbsp;@file:Suppress(
&nbsp;    &quot;unused&quot;,
&nbsp;    &quot;PrivatePropertyName&quot;,
&nbsp;    &quot;MemberVisibilityCanBePrivate&quot;,
&nbsp;)
&nbsp;
&nbsp;package team.duckie.quackquack.common.lint.util
&nbsp;
&nbsp;import org.jetbrains.kotlin.psi.KtLambdaExpression
&nbsp;import org.jetbrains.kotlin.psi.KtParameter
&nbsp;import org.jetbrains.kotlin.psi.KtSimpleNameExpression
&nbsp;import org.jetbrains.kotlin.psi.KtTypeReference
&nbsp;import org.jetbrains.kotlin.psi.psiUtil.collectDescendantsOfType
&nbsp;import org.jetbrains.kotlin.psi.psiUtil.isAncestor
&nbsp;import org.jetbrains.uast.ULambdaExpression
&nbsp;import org.jetbrains.uast.UParameter
&nbsp;import org.jetbrains.uast.toUElement
&nbsp;
&nbsp;/**
&nbsp; * 암시적 매개변수 `it` 을 나타냅니다.
&nbsp; */
&nbsp;const val ItName = &quot;it&quot;
&nbsp;
&nbsp;/**
&nbsp; * [UParameter] 의 타입 레퍼런스와 타입명을 제공하는 레퍼 클래스 입니다.
&nbsp; * [UParameter.typed] 의 반환 타입으로만 사용됩니다. 따라서 internal 생성자를 갖습니다.
&nbsp; */
&nbsp;class UParameterType internal constructor(
&nbsp;    val reference: KtTypeReference,
&nbsp;    val name: String,
&nbsp;) {
&nbsp;    internal constructor(typeReference: KtTypeReference) : this(
&nbsp;        reference = typeReference,
&nbsp;        name = typeReference.text,
&nbsp;    )
&nbsp;
&nbsp;    operator fun component1() = reference
&nbsp;    operator fun component2() = name
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * 주어진 [UParameter] 의 타입 레퍼런스와 타입명을 반환합니다.
&nbsp; */
&nbsp;val UParameter.typed: UParameterType? // 타입 명시 필수
&nbsp;    get() {
<b class="pc">&nbsp;        val typeReference = (sourcePsi as? KtParameter)?.typeReference ?: return null</b>
<b class="fc">&nbsp;        return UParameterType(</b>
<b class="fc">&nbsp;            typeReference = typeReference,</b>
&nbsp;        )
&nbsp;    }
&nbsp;
&nbsp;/**
&nbsp; * Returns a list of unreferenced parameters in [this]. If no parameters have been specified, but
&nbsp; * there is an implicit `it` parameter, this will return a list containing an
&nbsp; * [UnreferencedParameter] with `it` as the name.
&nbsp; */
&nbsp;fun ULambdaExpression.findUnreferencedParameters(): List&lt;UnreferencedParameter&gt; {
<b class="pc">&nbsp;    val lambdaExpression = sourcePsi as? KtLambdaExpression ?: return emptyList()</b>
<b class="fc">&nbsp;    return LambdaParameterVisitor(lambdaExpression).findUnreferencedParameters()</b>
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Helper class that visits references inside [lambda], calculating what parameters within
&nbsp; * [lambda] are unreferenced inside the expression.
&nbsp; */
&nbsp;private class LambdaParameterVisitor(private val lambda: KtLambdaExpression) {
&nbsp;    /**
&nbsp;     * Returns a list of [UnreferencedParameter]s inside [lambda]. Inner lambdas are checked to
&nbsp;     * ensure that they are not shadowing a parameter name, as a reference inside a shadowed lambda
&nbsp;     * will refer to that lambda&#39;s parameter, and not the outer parameter.
&nbsp;     *
&nbsp;     * If no parameters have been specified, but there is an implicit `it` parameter, this will
&nbsp;     * return a list containing an [UnreferencedParameter] with `it` as the name.
&nbsp;     */
&nbsp;    fun findUnreferencedParameters(): List&lt;UnreferencedParameter&gt; {
&nbsp;        return if (lambda.hasImplicitItParameter) {
&nbsp;            if (isParameterReferenced(ItName)) {
&nbsp;                emptyList()
&nbsp;            } else {
&nbsp;                listOf(UnreferencedParameter(ItName, null))
&nbsp;            }
&nbsp;        } else {
&nbsp;            lambda.valueParameters
&nbsp;                .filter { parameter -&gt;
&nbsp;                    parameter.destructuringDeclaration == null
&nbsp;                }
&nbsp;                .filterNot { parameter -&gt;
&nbsp;                    isParameterReferenced(parameter.name!!)
&nbsp;                }
&nbsp;                .map { parameter -&gt;
&nbsp;                    UnreferencedParameter(parameter.name!!, parameter)
&nbsp;                }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun isParameterReferenced(name: String): Boolean {
&nbsp;        val matchingReferences = references.filter { expression -&gt;
&nbsp;            expression.getReferencedName() == name
&nbsp;        }
&nbsp;
&nbsp;        if (matchingReferences.isEmpty()) return false
&nbsp;
&nbsp;        val lambdasWithMatchingParameterName = innerLambdas.filter { innerLambda -&gt;
&nbsp;            if (innerLambda.hasImplicitItParameter) {
&nbsp;                name == ItName
&nbsp;            } else {
&nbsp;                innerLambda.valueParameters
&nbsp;                    .filter { parameter -&gt;
&nbsp;                        parameter.destructuringDeclaration == null
&nbsp;                    }
&nbsp;                    .any { parameter -&gt;
&nbsp;                        parameter.name == name
&nbsp;                    }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return matchingReferences.any { reference -&gt;
&nbsp;            lambdasWithMatchingParameterName.none { expression -&gt;
&nbsp;                expression.isAncestor(reference)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private val references by lazy {
&nbsp;        lambda.functionLiteral.collectDescendantsOfType&lt;KtSimpleNameExpression&gt;()
&nbsp;    }
&nbsp;    private val innerLambdas by lazy {
&nbsp;        lambda.functionLiteral.collectDescendantsOfType&lt;KtLambdaExpression&gt;()
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Represents an unreferenced parameter.
&nbsp; *
&nbsp; * @property name the name of the parameter - if the parameter is an implicit `it` parameter,
&nbsp; * this will be &quot;it&quot;
&nbsp; * @property parameter the parameter that is not referenced - can be null if the parameter is an
&nbsp; * implicit `it` parameter
&nbsp; */
&nbsp;class UnreferencedParameter(
&nbsp;    val name: String,
&nbsp;    val parameter: KtParameter?,
&nbsp;)
&nbsp;
&nbsp;/**
&nbsp; * Returns whether this lambda expression has an implicit `it` parameter - meaning it has
&nbsp; * one parameter, and the parameter is not named explicitly.
&nbsp; */
&nbsp;val KtLambdaExpression.hasImplicitItParameter: Boolean // 타입 명시 필수
&nbsp;    get() {
<b class="fc">&nbsp;        return when {</b>
<b class="fc">&nbsp;            functionLiteral.hasParameterSpecification() -&gt; false</b>
<b class="pc">&nbsp;            (toUElement() as? ULambdaExpression)?.valueParameters?.size != 1 -&gt; false</b>
<b class="fc">&nbsp;            else -&gt; true</b>
&nbsp;        }
&nbsp;    }
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-20 14:04</div>
</div>
</body>
</html>
