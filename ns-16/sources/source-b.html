


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TextfieldKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">team.duckie.quackquack.ui.component</a>
</div>

<h1>Coverage Summary for Class: TextfieldKt (team.duckie.quackquack.ui.component)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">TextfieldKt</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.9%
  </span>
  <span class="absValue">
    (33/114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (65/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71%
  </span>
  <span class="absValue">
    (568/800)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TextfieldKt$QuackBasicTextField$1$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TextfieldKt$QuackBasicTextField$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83%
  </span>
  <span class="absValue">
    (44/53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TextfieldKt$QuackBasicTextField$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">TextfieldKt$QuackTextFieldDecorationBox$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (14/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.2%
  </span>
  <span class="absValue">
    (31/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.1%
  </span>
  <span class="absValue">
    (174/189)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TextfieldKt$QuackTextFieldDecorationBox$3$measure$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94%
  </span>
  <span class="absValue">
    (63/67)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.3%
  </span>
  <span class="absValue">
    (53/150)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.4%
  </span>
  <span class="absValue">
    (113/125)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.7%
  </span>
  <span class="absValue">
    (854/1114)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Designed and developed by 2022 SungbinLand, Team Duckie
&nbsp; *
&nbsp; * Licensed under the MIT.
&nbsp; * Please see full license: https://github.com/sungbinland/quack-quack/blob/main/LICENSE
&nbsp; */
&nbsp;
&nbsp;@file:NoLiveLiterals
&nbsp;
&nbsp;package team.duckie.quackquack.ui.component
&nbsp;
&nbsp;import androidx.compose.foundation.border
&nbsp;import androidx.compose.foundation.layout.Box
&nbsp;import androidx.compose.foundation.layout.size
&nbsp;import androidx.compose.foundation.text.BasicTextField
&nbsp;import androidx.compose.foundation.text.KeyboardActions
&nbsp;import androidx.compose.foundation.text.KeyboardOptions
&nbsp;import androidx.compose.runtime.Composable
&nbsp;import androidx.compose.runtime.NoLiveLiterals
&nbsp;import androidx.compose.runtime.getValue
&nbsp;import androidx.compose.runtime.mutableStateOf
&nbsp;import androidx.compose.runtime.remember
&nbsp;import androidx.compose.runtime.setValue
&nbsp;import androidx.compose.ui.Alignment
&nbsp;import androidx.compose.ui.Modifier
&nbsp;import androidx.compose.ui.graphics.Color
&nbsp;import androidx.compose.ui.layout.Layout
&nbsp;import androidx.compose.ui.layout.layoutId
&nbsp;import androidx.compose.ui.layout.onPlaced
&nbsp;import androidx.compose.ui.platform.LocalDensity
&nbsp;import androidx.compose.ui.text.input.ImeAction
&nbsp;import androidx.compose.ui.text.style.TextAlign
&nbsp;import androidx.compose.ui.unit.Constraints
&nbsp;import androidx.compose.ui.unit.IntSize
&nbsp;import androidx.compose.ui.unit.dp
&nbsp;import team.duckie.quackquack.common.npe
&nbsp;import team.duckie.quackquack.ui.constant.QuackHeight
&nbsp;import team.duckie.quackquack.ui.constant.QuackWidth
&nbsp;import team.duckie.quackquack.ui.modifier.applyQuackSize
&nbsp;import team.duckie.quackquack.ui.textstyle.QuackTextStyle
&nbsp;
&nbsp;// old codebase:
&nbsp;// https://github.com/sungbinland/duckie-quack-quack/blob/6e0701a29711f2850d9b0449a286e8c282672982/ui-components/src/main/kotlin/team/duckie/quackquack/ui/component/textfield.kt
&nbsp;
&nbsp;/**
&nbsp; * This padding adds spaces in between the text-field and decoration content i.e leading and trailing content
&nbsp; * ```
&nbsp; * Decoration - TextField - Decoration
&nbsp; * ```
&nbsp; *
&nbsp; * As an example, see [this](https://user-images.githubusercontent.com/40740128/189829870-cba93fd6-d5f4-4016-b826-c6093cfbb386.png) image,
&nbsp; * the decoration item is the part inside the orange rectangle,
&nbsp; * and the TextField is the &quot;placeholder&quot; part.
&nbsp; */
<b class="fc">&nbsp;private val QuackTextFieldDecorationContentHorizontalPadding = 8.dp</b>
&nbsp;
&nbsp;/**
&nbsp; * Draws the most basic QuackTextField.
&nbsp; * Add only decoration items that fit QuackTextField to BasicTextField.
&nbsp; *
&nbsp; * The current implementation only works if the height is statically fixed.
&nbsp; * That is, if you specify height as wrap_content, height is always displayed as 0.
&nbsp; * This should be fixed.
&nbsp; *
&nbsp; * @param modifier [Modifier] to use to draw the QuackBasicTextField
&nbsp; * @param text text to display
&nbsp; * @param onTextChanged Callback to be invoked when new text is entered
&nbsp; * @param textStyle The style of the text to be displayed.
&nbsp; * @param width Width of QuackTextField
&nbsp; * @param height height of QuackTextField
&nbsp; * @param keyboardOptions keyboard options in QuackTextField
&nbsp; * @param keyboardActions Keyboard actions in QuackTextField
&nbsp; * @param leadingContent leading decoration content of QuackTextField
&nbsp; * @param trailingContent trailing decoration content of QuackTextField
&nbsp; */
&nbsp;@Composable
&nbsp;fun QuackBasicTextField(
<b class="pc">&nbsp;    modifier: Modifier = Modifier,</b>
&nbsp;    text: String,
&nbsp;    onTextChanged: (text: String) -&gt; Unit,
<b class="pc">&nbsp;    textStyle: QuackTextStyle = QuackTextStyle.Body1,</b>
<b class="pc">&nbsp;    width: QuackWidth = QuackWidth.Fill,</b>
<b class="nc">&nbsp;    height: QuackHeight = QuackHeight.Wrap,</b>
<b class="pc">&nbsp;    keyboardOptions: KeyboardOptions = KeyboardOptions(</b>
<b class="fc">&nbsp;        imeAction = ImeAction.Done,</b>
&nbsp;    ),
<b class="pc">&nbsp;    keyboardActions: KeyboardActions = KeyboardActions(),</b>
<b class="nc">&nbsp;    leadingContent: @Composable (() -&gt; Unit)? = null,</b>
<b class="nc">&nbsp;    trailingContent: @Composable (() -&gt; Unit)? = null,</b>
<b class="pc">&nbsp;) {</b>
<b class="fc">&nbsp;    var textFieldSize by remember {</b>
<b class="fc">&nbsp;        mutableStateOf(</b>
<b class="fc">&nbsp;            value = IntSize.Zero,</b>
&nbsp;        )
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    BasicTextField(</b>
<b class="fc">&nbsp;        modifier = modifier</b>
<b class="fc">&nbsp;            .applyQuackSize(</b>
<b class="fc">&nbsp;                width = width,</b>
<b class="fc">&nbsp;                height = height,</b>
&nbsp;            )
<b class="fc">&nbsp;            .border(</b>
<b class="fc">&nbsp;                color = Color.Gray,</b>
<b class="fc">&nbsp;                width = 1.dp,</b>
&nbsp;            )
<b class="fc">&nbsp;            .onPlaced { layoutCoordinates -&gt;</b>
<b class="fc">&nbsp;                textFieldSize = layoutCoordinates.size</b>
&nbsp;            },
<b class="fc">&nbsp;        value = text,</b>
<b class="fc">&nbsp;        onValueChange = onTextChanged,</b>
&nbsp;        // TextField&#39;s TextStyle should not be animated
<b class="fc">&nbsp;        textStyle = textStyle.change(</b>
<b class="fc">&nbsp;            textAlign = TextAlign.Start,</b>
<b class="fc">&nbsp;        ).asComposeStyle(),</b>
<b class="fc">&nbsp;        keyboardOptions = keyboardOptions,</b>
<b class="fc">&nbsp;        keyboardActions = keyboardActions,</b>
&nbsp;        // TextField is always single line
&nbsp;        // TextArea is always multi line
<b class="fc">&nbsp;        singleLine = true,</b>
<b class="fc">&nbsp;        decorationBox = { textField -&gt;</b>
<b class="pc">&nbsp;            QuackTextFieldDecorationBox(</b>
<b class="fc">&nbsp;                textFieldSize = textFieldSize,</b>
&nbsp;                textField = textField,
<b class="fc">&nbsp;                leadingContent = leadingContent,</b>
<b class="fc">&nbsp;                trailingContent = trailingContent,</b>
<b class="nc">&nbsp;            )</b>
&nbsp;        },
&nbsp;    )
<b class="nc">&nbsp;}</b>
&nbsp;
&nbsp;private const val QuackTextFieldLayoutId = &quot;QuackTextFieldContent&quot;
&nbsp;private const val QuackTextFieldLeadingContentLayoutId = &quot;QuackTextFieldLeadingContent&quot;
&nbsp;private const val QuackTextFieldTrailingContentLayoutId = &quot;QuackTextFieldTrailingContent&quot;
&nbsp;
&nbsp;/**
&nbsp; * A decoration box used to draw decoration items for QuackTextField.
&nbsp; *
&nbsp; * @param textFieldSize The size of QuackTextField layout
&nbsp; * @param textField BasicTextField to be treated as QuackTextField
&nbsp; * @param leadingContent The leading content of QuackTextField
&nbsp; * @param trailingContent The trailing content of QuackTextField
&nbsp; *
&nbsp; * @see QuackTextFieldDecorationContentHorizontalPadding
&nbsp; */
&nbsp;@Composable
&nbsp;private inline fun QuackTextFieldDecorationBox(
&nbsp;    textFieldSize: IntSize,
&nbsp;    textField: @Composable () -&gt; Unit,
&nbsp;    noinline leadingContent: @Composable (() -&gt; Unit)?,
&nbsp;    noinline trailingContent: @Composable (() -&gt; Unit)?,
&nbsp;) {
<b class="fc">&nbsp;    val density = LocalDensity.current</b>
&nbsp;    // `QuackTextFieldDecorationContentHorizontalPadding` is a constant value,
&nbsp;    // so there is no need to remember the key
<b class="fc">&nbsp;    val decorationItemGap = remember {</b>
<b class="fc">&nbsp;        with(</b>
&nbsp;            receiver = density,
&nbsp;        ) {
<b class="fc">&nbsp;            QuackTextFieldDecorationContentHorizontalPadding.roundToPx()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Layout(</b>
<b class="fc">&nbsp;        modifier = Modifier</b>
<b class="fc">&nbsp;            .size(</b>
<b class="fc">&nbsp;                width = with(</b>
&nbsp;                    receiver = density,
&nbsp;                ) {
<b class="fc">&nbsp;                    textFieldSize.width.toDp()</b>
&nbsp;                },
<b class="fc">&nbsp;                height = with(</b>
&nbsp;                    receiver = density,
&nbsp;                ) {
<b class="fc">&nbsp;                    textFieldSize.height.toDp()</b>
&nbsp;                },
&nbsp;            ),
&nbsp;        content = {
<b class="pc">&nbsp;            if (leadingContent != null) {</b>
<b class="fc">&nbsp;                Box(</b>
<b class="fc">&nbsp;                    modifier = Modifier.layoutId(</b>
<b class="fc">&nbsp;                        layoutId = QuackTextFieldLeadingContentLayoutId,</b>
&nbsp;                    ),
<b class="fc">&nbsp;                    contentAlignment = Alignment.Center,</b>
<b class="fc">&nbsp;                    propagateMinConstraints = true,</b>
&nbsp;                ) {
<b class="pc">&nbsp;                    leadingContent()</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            Box(</b>
<b class="fc">&nbsp;                modifier = Modifier.layoutId(</b>
<b class="fc">&nbsp;                    layoutId = QuackTextFieldLayoutId,</b>
&nbsp;                ),
<b class="fc">&nbsp;                contentAlignment = Alignment.Center,</b>
<b class="fc">&nbsp;                propagateMinConstraints = true,</b>
&nbsp;            ) {
<b class="pc">&nbsp;                textField()</b>
<b class="fc">&nbsp;            }</b>
<b class="pc">&nbsp;            if (trailingContent != null) {</b>
<b class="fc">&nbsp;                Box(</b>
<b class="fc">&nbsp;                    modifier = Modifier.layoutId(</b>
<b class="fc">&nbsp;                        layoutId = QuackTextFieldTrailingContentLayoutId,</b>
&nbsp;                    ),
<b class="fc">&nbsp;                    contentAlignment = Alignment.Center,</b>
<b class="fc">&nbsp;                    propagateMinConstraints = true,</b>
&nbsp;                ) {
<b class="pc">&nbsp;                    trailingContent()</b>
<b class="fc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;        },</b>
<b class="fc">&nbsp;    ) { measurables, _ -&gt;</b>
&nbsp;        // The current implementation assumes that the shape of the
&nbsp;        // decoration item is always square. However, the actual shape of
&nbsp;        // the decoration item may not be square. For instance, see the images below.
&nbsp;        //
&nbsp;        // [TextField decoration items - square version]
&nbsp;        // https://user-images.githubusercontent.com/40740128/189829870-cba93fd6-d5f4-4016-b826-c6093cfbb386.png
&nbsp;        //
&nbsp;        // [TextField decoration items - rectangular version]
&nbsp;        // https://user-images.githubusercontent.com/40740128/189829922-667b1297-86fa-4e86-9db0-56de1d3ac778.png
&nbsp;        //
&nbsp;        // Regardless of the shape, the height of the decoration item is always the same as
&nbsp;        // the height of the TextField, as for the width,
&nbsp;        // it&#39;s size is equal to the total length content of the decorated item [wrap_content]
<b class="fc">&nbsp;        val decorationItemConstraints = Constraints.fixed(</b>
<b class="fc">&nbsp;            width = textFieldSize.height,</b>
<b class="fc">&nbsp;            height = textFieldSize.height,</b>
&nbsp;        )
&nbsp;
&nbsp;        // leading content
<b class="pc">&nbsp;        val leadingContentPlaceable = measurables.find { measurable -&gt;</b>
<b class="fc">&nbsp;            measurable.layoutId == QuackTextFieldLeadingContentLayoutId</b>
<b class="pc">&nbsp;        }?.measure(</b>
<b class="fc">&nbsp;            constraints = decorationItemConstraints,</b>
&nbsp;        )
&nbsp;
&nbsp;        // trailing content
<b class="pc">&nbsp;        val trailingContentPlaceable = measurables.find { measurable -&gt;</b>
<b class="fc">&nbsp;            measurable.layoutId == QuackTextFieldTrailingContentLayoutId</b>
<b class="pc">&nbsp;        }?.measure(</b>
<b class="fc">&nbsp;            constraints = decorationItemConstraints,</b>
&nbsp;        )
&nbsp;
&nbsp;        // The width of the TextField is determined by subtracting the width of
&nbsp;        // both decoration items and the padding between the decoration item and
&nbsp;        // the TextField from the total size of the TextField&#39;s layout.
<b class="fc">&nbsp;        val textFieldWidth = textFieldSize.width.let { _width -&gt;</b>
<b class="fc">&nbsp;            var width = _width</b>
<b class="pc">&nbsp;            if (leadingContentPlaceable != null) {</b>
<b class="fc">&nbsp;                width -= leadingContentPlaceable.width + decorationItemGap</b>
&nbsp;            }
<b class="pc">&nbsp;            if (trailingContentPlaceable != null) {</b>
<b class="fc">&nbsp;                width -= trailingContentPlaceable.width + decorationItemGap</b>
&nbsp;            }
<b class="fc">&nbsp;            width</b>
<b class="fc">&nbsp;        }.coerceAtLeast(</b>
<b class="fc">&nbsp;            minimumValue = 0,</b>
&nbsp;        )
&nbsp;
&nbsp;        // TextField
<b class="pc">&nbsp;        val textFieldPlaceable = measurables.find { measurable -&gt;</b>
<b class="fc">&nbsp;            measurable.layoutId == QuackTextFieldLayoutId</b>
<b class="pc">&nbsp;        }?.measure(</b>
<b class="fc">&nbsp;            constraints = Constraints(</b>
&nbsp;                // The width of the TextField layout basically includes the width
&nbsp;                // of decoration items. If there is a decoration item, the width of
&nbsp;                // the TextField should be reduced by the width of the decoration item.
&nbsp;                // Therefore, it is set as the width of the TextField by subtracting
&nbsp;                // the width of the decoration item and the space between the TextField
&nbsp;                // and the decoration item from the width of the TextField layout.
<b class="fc">&nbsp;                minWidth = textFieldWidth,</b>
<b class="fc">&nbsp;                maxWidth = textFieldWidth,</b>
<b class="fc">&nbsp;                minHeight = 0,</b>
<b class="fc">&nbsp;                maxHeight = Constraints.Infinity,</b>
&nbsp;            ),
<b class="nc">&nbsp;        ) ?: npe(</b>
&nbsp;            lazyMessage = {
<b class="nc">&nbsp;                notFoundRequiredLayoutIdForQuackTextFieldMessage(</b>
<b class="nc">&nbsp;                    layoutId = QuackTextFieldLayoutId,</b>
&nbsp;                )
&nbsp;            },
&nbsp;        )
&nbsp;
<b class="fc">&nbsp;        layout(</b>
<b class="fc">&nbsp;            width = textFieldSize.width,</b>
<b class="fc">&nbsp;            height = textFieldSize.height,</b>
&nbsp;        ) {
<b class="pc">&nbsp;            val textFieldStartOffset = leadingContentPlaceable?.width?.plus(</b>
<b class="fc">&nbsp;                other = decorationItemGap,</b>
<b class="nc">&nbsp;            ) ?: 0</b>
&nbsp;
&nbsp;            // Center the TextField in the TextField&#39;s layout
<b class="fc">&nbsp;            val textFieldYOffset = textFieldSize.height / 2 - textFieldPlaceable.height / 2</b>
&nbsp;
<b class="pc">&nbsp;            leadingContentPlaceable?.place(</b>
<b class="fc">&nbsp;                x = 0,</b>
<b class="fc">&nbsp;                y = 0,</b>
&nbsp;            )
<b class="fc">&nbsp;            textFieldPlaceable.place(</b>
<b class="fc">&nbsp;                x = textFieldStartOffset,</b>
<b class="fc">&nbsp;                y = textFieldYOffset,</b>
&nbsp;            )
<b class="pc">&nbsp;            trailingContentPlaceable?.place(</b>
<b class="fc">&nbsp;                x = textFieldSize.width - trailingContentPlaceable.width,</b>
<b class="fc">&nbsp;                y = 0,</b>
&nbsp;            )
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Return an exception message when it cannot find the layoutId
&nbsp; * needed to measure the QuackTextField.
&nbsp; *
&nbsp; * @param layoutId The layoutId needed to measure the QuackTextField
&nbsp; * @return The exception message
&nbsp; */
&nbsp;@Suppress(&quot;SameParameterValue&quot;)
&nbsp;private fun notFoundRequiredLayoutIdForQuackTextFieldMessage(
&nbsp;    layoutId: String,
&nbsp;) = &quot;&quot;&quot;
&nbsp;    |Could not find composable with the required layoutId for measurement QuackTextField.
&nbsp;    |Make sure you use QuackTextField in the right way.
&nbsp;
<b class="nc">&nbsp;    |Required layoutId: $layoutId</b>
<b class="nc">&nbsp;    &quot;&quot;&quot;.trimMargin()</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-09-17 11:15</div>
</div>
</body>
</html>
