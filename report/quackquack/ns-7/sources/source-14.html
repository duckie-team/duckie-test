


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > QuackTextFieldColors</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">team.duckie.quackquack.ui.component</a>
</div>

<h1>Coverage Summary for Class: QuackTextFieldColors (team.duckie.quackquack.ui.component)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">QuackTextFieldColors</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Designed and developed by 2022 SungbinLand, Team Duckie
&nbsp; *
&nbsp; * Licensed under the MIT.
&nbsp; * Please see full license: https://github.com/duckie-team/quack-quack-android/blob/master/LICENSE
&nbsp; */
&nbsp;
&nbsp;@file:NoLiveLiterals
&nbsp;
&nbsp;package team.duckie.quackquack.ui.component
&nbsp;
&nbsp;import androidx.compose.animation.AnimatedVisibility
&nbsp;import androidx.compose.animation.expandVertically
&nbsp;import androidx.compose.animation.fadeIn
&nbsp;import androidx.compose.animation.fadeOut
&nbsp;import androidx.compose.animation.shrinkVertically
&nbsp;import androidx.compose.foundation.background
&nbsp;import androidx.compose.foundation.layout.Box
&nbsp;import androidx.compose.foundation.layout.Column
&nbsp;import androidx.compose.foundation.layout.PaddingValues
&nbsp;import androidx.compose.foundation.layout.padding
&nbsp;import androidx.compose.foundation.layout.wrapContentSize
&nbsp;import androidx.compose.foundation.text.BasicTextField
&nbsp;import androidx.compose.foundation.text.KeyboardActions
&nbsp;import androidx.compose.foundation.text.KeyboardOptions
&nbsp;import androidx.compose.material.Text
&nbsp;import androidx.compose.runtime.Composable
&nbsp;import androidx.compose.runtime.Immutable
&nbsp;import androidx.compose.runtime.NoLiveLiterals
&nbsp;import androidx.compose.runtime.Stable
&nbsp;import androidx.compose.runtime.remember
&nbsp;import androidx.compose.ui.Alignment
&nbsp;import androidx.compose.ui.Modifier
&nbsp;import androidx.compose.ui.draw.drawWithContent
&nbsp;import androidx.compose.ui.focus.FocusRequester
&nbsp;import androidx.compose.ui.focus.focusRequester
&nbsp;import androidx.compose.ui.focus.onFocusChanged
&nbsp;import androidx.compose.ui.layout.Layout
&nbsp;import androidx.compose.ui.layout.layoutId
&nbsp;import androidx.compose.ui.text.font.FontWeight
&nbsp;import androidx.compose.ui.text.input.ImeAction
&nbsp;import androidx.compose.ui.text.style.TextOverflow
&nbsp;import androidx.compose.ui.unit.dp
&nbsp;import androidx.compose.ui.zIndex
&nbsp;import team.duckie.quackquack.ui.animation.QuackAnimationSpec
&nbsp;import team.duckie.quackquack.ui.color.QuackColor
&nbsp;import team.duckie.quackquack.ui.component.internal.QuackTextFieldLayoutId
&nbsp;import team.duckie.quackquack.ui.component.internal.QuackTextFieldLeadingContentLayoutId
&nbsp;import team.duckie.quackquack.ui.component.internal.QuackTextFieldMeasurePolicy.Companion.rememberQuackTextFieldMeasurePolicy
&nbsp;import team.duckie.quackquack.ui.component.internal.QuackTextFieldPlaceholderLayoutId
&nbsp;import team.duckie.quackquack.ui.component.internal.QuackTextFieldTrailingContentLayoutId
&nbsp;import team.duckie.quackquack.ui.constant.QuackHeight
&nbsp;import team.duckie.quackquack.ui.constant.QuackWidth
&nbsp;import team.duckie.quackquack.ui.modifier.applyQuackSize
&nbsp;import team.duckie.quackquack.ui.modifier.drawUnderBarWithAnimation
&nbsp;import team.duckie.quackquack.ui.textstyle.QuackTextStyle
&nbsp;import team.duckie.quackquack.ui.theme.LocalQuackTextFieldColors
&nbsp;import team.duckie.quackquack.ui.util.DoNotUseDirectly
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에서 표시할 텍스트의 [FontWeight] 에 따라 QuackTextField 의
&nbsp; * 높이가 달라집니다. 이를 계산하기 위해 사용됩니다.
&nbsp; *
&nbsp; * 만약 [FontWeight] 가 [FontWeight.Bold] 라면 TextField 에서 16dp 만큼 추가 높이를 갖고,
&nbsp; * 그렇지 않다면 18dp 만큼 추가 높이를 갖습니다.
&nbsp; *
&nbsp; * 좀 더 많은 경우를 신경쓰기 위해선 [FontWeight.Bold] 보다 큰 경우도 체크하면 좋지만,
&nbsp; * 현재 QuackTextField 의 디자인에는 최대 [FontWeight.Bold] 만 사용하고 있기 때문에
&nbsp; * [FontWeight.Bold] 만 체크합니다.
&nbsp; *
&nbsp; * @receiver [FontWeight] 가 [FontWeight.Bold] 인지 검사할 [QuackTextStyle]
&nbsp; * @return QuackTextField 에서 표시할 텍스트의 [FontWeight] 가 [FontWeight.Bold] 인지 여부
&nbsp; */
&nbsp;private val QuackTextStyle.isBold get() = weight == FontWeight.Bold
&nbsp;
&nbsp;/**
&nbsp; * This padding adds spaces in between the text-field and decoration content i.e leading and trailing content
&nbsp; * ```
&nbsp; * Decoration - TextField - Decoration
&nbsp; * ```
&nbsp; *
&nbsp; * As an example, see [this](https://user-images.githubusercontent.com/40740128/189829870-cba93fd6-d5f4-4016-b826-c6093cfbb386.png) image,
&nbsp; * the decoration item is the part inside the orange rectangle,
&nbsp; * and the TextField is the &quot;placeholder&quot; part.
&nbsp; */
&nbsp;private val QuackTextFieldDecorationContentHorizontalPadding = 8.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 밑에 표시될 ErrorText 와의 간격
&nbsp; */
&nbsp;private val QuackTextFieldErrorTextTopPadding = 4.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에서 표시하는 텍스트의 [FontWeight] 가
&nbsp; * [FontWeight.Bold] 가 아닐 때 TextField 위에 들어갈 패딩
&nbsp; *
&nbsp; * QuackTextField 의 높이를 결정짓는 중요한 요소가 됩니다.
&nbsp; *
&nbsp; * **이 API 는 직접적으로 사용하면 안됩니다.**
&nbsp; * 대신에 [QuackTextStyle.calcQuackTextFieldTopPadding] 를 사용하세요.
&nbsp; *
&nbsp; * @see QuackTextStyle.isBold
&nbsp; */
&nbsp;@DoNotUseDirectly
&nbsp;private val QuackTextFieldTopPaddingWithNonBold = 18.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에서 표시하는 텍스트의 [FontWeight] 가
&nbsp; * [FontWeight.Bold] 일 때 TextField 위에 들어갈 패딩
&nbsp; *
&nbsp; * QuackTextField 의 높이를 결정짓는 중요한 요소가 됩니다.
&nbsp; *
&nbsp; * **이 API 는 직접적으로 사용하면 안됩니다.**
&nbsp; * 대신에 [QuackTextStyle.calcQuackTextFieldTopPadding] 를 사용하세요.
&nbsp; *
&nbsp; * @see QuackTextStyle.isBold
&nbsp; */
&nbsp;@DoNotUseDirectly
&nbsp;private val QuackTextFieldTopPaddingWithBold = 16.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에서 표시하는 텍스트의 [FontWeight] 에 따라 TextField 위에 들어갈 패딩을 계산합니다.
&nbsp; *
&nbsp; * @return TextField 위에 들어갈 패딩
&nbsp; * @see QuackTextStyle.isBold
&nbsp; */
&nbsp;@OptIn(DoNotUseDirectly::class)
&nbsp;private fun QuackTextStyle.calcQuackTextFieldTopPadding() = when (isBold) {
&nbsp;    true -&gt; QuackTextFieldTopPaddingWithBold
&nbsp;    else -&gt; QuackTextFieldTopPaddingWithNonBold
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에 사용되는 TextField 의 하단에 들어갈 패딩
&nbsp; */
&nbsp;private val QuackTextFieldBottomPadding = 8.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에 표시될 언더바의 높이
&nbsp; */
&nbsp;private val QuackTextFieldUnderBarHeight = 1.dp
&nbsp;
&nbsp;/**
&nbsp; * QuackTextField 에서 사용할 아이템들의 색상을 계산하기 위한
&nbsp; * 유틸 함수들이 있는 클래스 입니다.
&nbsp; */
&nbsp;@Immutable
&nbsp;private object QuackTextFieldColors {
&nbsp;    /**
&nbsp;     * QuackTextField 에 표시될 텍스트의 색상을 계산합니다.
&nbsp;     * placeholder 인지 여부에 따라 색상이 달라집니다.
&nbsp;     *
&nbsp;     * @param isPlaceholder placeholder 로 보여지고 있는지 여부
&nbsp;     * @return QuackTextField 에 표시될 텍스트의 색상
&nbsp;     */
&nbsp;    @Stable
&nbsp;    fun textColor(
&nbsp;        isPlaceholder: Boolean,
<b class="fc">&nbsp;    ) = when (isPlaceholder) {</b>
<b class="fc">&nbsp;        true -&gt; QuackColor.Gray2</b>
<b class="fc">&nbsp;        else -&gt; QuackColor.Black</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * QuackTextField 에 표시될 언더바의 색상을 계산합니다.
&nbsp;     * 현재 에러 상태인지에 따라 색상이 달라집니다.
&nbsp;     *
&nbsp;     * @param isError 현재 QuackTextField 가 에러 상태인지 여부
&nbsp;     * @return QuackTextField 에 표시될 언더바의 색상
&nbsp;     */
&nbsp;    @Stable
&nbsp;    fun underBarColor(
&nbsp;        isError: Boolean,
<b class="fc">&nbsp;    ) = when (isError) {</b>
<b class="fc">&nbsp;        true -&gt; QuackColor.OrangeRed</b>
<b class="fc">&nbsp;        else -&gt; QuackColor.Gray3</b>
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Draws the most basic QuackQuack&#39;s TextField.
&nbsp; * Add only decoration items that fit QuackTextField to BasicTextField.
&nbsp; *
&nbsp; * Always use [QuackAnimationSpec] as animationSpec.
&nbsp; *
&nbsp; * @param width Width of QuackTextField
&nbsp; * @param height height of QuackTextField
&nbsp; * @param text text to display
&nbsp; * @param onTextChanged Callback to be invoked when new text is entered
&nbsp; * @param textStyle The style of the text to be displayed.
&nbsp; * @param placeholderText A placeholder text to display when the entered
&nbsp; * [text] is empty. According to the design guide of QuackTextField, only
&nbsp; * single text can be placed in placeholder.
&nbsp; * @param isError Whether the QuackTextField is in error state
&nbsp; * @param errorText A text to display when the QuackTextField is in error state.
&nbsp; * @param errorTextStyle The style of the [errorText] to be displayed.
&nbsp; * @param leadingContent leading decoration content of QuackTextField
&nbsp; * @param trailingContent trailing decoration content of QuackTextField
&nbsp; * @param keyboardOptions keyboard options in QuackTextField
&nbsp; * @param keyboardActions Keyboard actions in QuackTextField
&nbsp; */
&nbsp;@Composable
&nbsp;public fun QuackTextField(
&nbsp;    width: QuackWidth = QuackWidth.Fill,
&nbsp;    height: QuackHeight = QuackHeight.Wrap,
&nbsp;    text: String,
&nbsp;    onTextChanged: (text: String) -&gt; Unit,
&nbsp;    textStyle: QuackTextStyle = QuackTextStyle.Body1,
&nbsp;    placeholderText: String? = null,
&nbsp;    isError: Boolean = false,
&nbsp;    errorText: String? = null,
&nbsp;    // needs remember?
&nbsp;    errorTextStyle: QuackTextStyle = remember {
&nbsp;        QuackTextStyle.Body1.change(
&nbsp;            color = QuackColor.OrangeRed,
&nbsp;        )
&nbsp;    },
&nbsp;    leadingContent: (@Composable () -&gt; Unit)? = null,
&nbsp;    trailingContent: (@Composable () -&gt; Unit)? = null,
&nbsp;    keyboardOptions: KeyboardOptions = KeyboardOptions(
&nbsp;        imeAction = ImeAction.Done,
&nbsp;    ),
&nbsp;    keyboardActions: KeyboardActions = KeyboardActions(),
&nbsp;    focusRequester: FocusRequester = FocusRequester(),
&nbsp;    onFocusChanged: (Boolean) -&gt; Unit = {},
&nbsp;) {
&nbsp;    val errorComposeTextStyle = remember(
&nbsp;        key1 = errorTextStyle,
&nbsp;    ) {
&nbsp;        errorTextStyle.asComposeStyle()
&nbsp;    }
&nbsp;
&nbsp;    Column(
&nbsp;        modifier = Modifier
&nbsp;            .wrapContentSize()
&nbsp;            .focusRequester(focusRequester)
&nbsp;            .onFocusChanged {
&nbsp;                onFocusChanged(it.isFocused)
&nbsp;            },
&nbsp;    ) {
&nbsp;        QuackBasicTextField(
&nbsp;            width = width,
&nbsp;            height = height,
&nbsp;            text = text,
&nbsp;            onTextChanged = onTextChanged,
&nbsp;            textStyle = textStyle,
&nbsp;            placeholderText = placeholderText,
&nbsp;            isError = isError,
&nbsp;            leadingContent = leadingContent,
&nbsp;            trailingContent = trailingContent,
&nbsp;            keyboardOptions = keyboardOptions,
&nbsp;            keyboardActions = keyboardActions,
&nbsp;        )
&nbsp;        // 에러 상태 가능성이 있는 경우 에러 메시지가 표시될 공간을 항상
&nbsp;        // 확보하기 위해 미리 에러 메시지의 공간만 차지합니다.
&nbsp;        // 그렇지 않으면 에러 메시지가 보일 때 없던 공간이 갑자기 확장되면서
&nbsp;        // 순간적으로 레이아웃의 높이에 변동이 생깁니다.
&nbsp;        Box(
&nbsp;            modifier = Modifier.wrapContentSize(),
&nbsp;        ) {
&nbsp;            if (errorText != null) {
&nbsp;                Text(
&nbsp;                    modifier = Modifier
&nbsp;                        .padding(
&nbsp;                            top = QuackTextFieldErrorTextTopPadding,
&nbsp;                        )
&nbsp;                        .zIndex(
&nbsp;                            zIndex = 1f,
&nbsp;                        )
&nbsp;                        .drawWithContent {},
&nbsp;                    text = errorText,
&nbsp;                    style = errorComposeTextStyle,
&nbsp;                )
&nbsp;            }
&nbsp;            this@Column.AnimatedVisibility(
&nbsp;                visible = isError,
&nbsp;                modifier = Modifier.zIndex(
&nbsp;                    zIndex = 2f,
&nbsp;                ),
&nbsp;                enter = fadeIn(
&nbsp;                    animationSpec = QuackAnimationSpec(),
&nbsp;                ) + expandVertically(
&nbsp;                    animationSpec = QuackAnimationSpec(),
&nbsp;                ),
&nbsp;                exit = fadeOut(
&nbsp;                    animationSpec = QuackAnimationSpec(),
&nbsp;                ) + shrinkVertically(
&nbsp;                    animationSpec = QuackAnimationSpec(),
&nbsp;                ),
&nbsp;            ) {
&nbsp;                checkNotNull(
&nbsp;                    value = errorText,
&nbsp;                ) {
&nbsp;                    &quot;errorText must not be null when isError is true&quot;
&nbsp;                }
&nbsp;                Text(
&nbsp;                    modifier = Modifier.padding(
&nbsp;                        top = QuackTextFieldErrorTextTopPadding,
&nbsp;                    ),
&nbsp;                    text = errorText,
&nbsp;                    style = errorComposeTextStyle,
&nbsp;                )
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Draws the most basic QuackQuack&#39;s TextField.
&nbsp; * Add only decoration items that fit QuackTextField to [BasicTextField].
&nbsp; *
&nbsp; * @param width Width of QuackTextField
&nbsp; * @param height height of QuackTextField
&nbsp; * @param text text to display
&nbsp; * @param onTextChanged Callback to be invoked when new text is entered
&nbsp; * @param textStyle The style of the text to be displayed.
&nbsp; * @param placeholderText A placeholder text to display when the entered [text] is empty
&nbsp; * @param isError Whether the QuackTextField is in error state
&nbsp; * @param leadingContent leading decoration content of QuackTextField
&nbsp; * @param trailingContent trailing decoration content of QuackTextField
&nbsp; * @param keyboardOptions keyboard options in QuackTextField
&nbsp; * @param keyboardActions Keyboard actions in QuackTextField
&nbsp; */
&nbsp;@Composable
&nbsp;internal fun QuackBasicTextField(
&nbsp;    width: QuackWidth = QuackWidth.Fill,
&nbsp;    height: QuackHeight = QuackHeight.Wrap,
&nbsp;    text: String,
&nbsp;    onTextChanged: (text: String) -&gt; Unit,
&nbsp;    textStyle: QuackTextStyle = QuackTextStyle.Body1,
&nbsp;    placeholderText: String? = null,
&nbsp;    isError: Boolean = false,
&nbsp;    leadingContent: (@Composable () -&gt; Unit)? = null,
&nbsp;    trailingContent: (@Composable () -&gt; Unit)? = null,
&nbsp;    keyboardOptions: KeyboardOptions = KeyboardOptions(
&nbsp;        imeAction = ImeAction.Done,
&nbsp;    ),
&nbsp;    keyboardActions: KeyboardActions = KeyboardActions(),
&nbsp;) {
&nbsp;    val quackTextFieldColors = LocalQuackTextFieldColors.current
&nbsp;
&nbsp;    // 리컴포지션이 되는 메인 조건은 Text 가 바뀌었을 때인데 그러면
&nbsp;    // 어차피 항상 재계산 되므로 굳이 remember 를 할 필요가 없음
&nbsp;    val isPlaceholder = text.isEmpty()
&nbsp;
&nbsp;    // TextField&#39;s TextStyle should not be animated
&nbsp;    val composeTextStyle = remember(
&nbsp;        key1 = textStyle,
&nbsp;        key2 = isPlaceholder,
&nbsp;    ) {
&nbsp;        textStyle.change(
&nbsp;            color = QuackTextFieldColors.textColor(
&nbsp;                isPlaceholder = isPlaceholder,
&nbsp;            ),
&nbsp;        ).asComposeStyle()
&nbsp;    }
&nbsp;
&nbsp;    BasicTextField(
&nbsp;        modifier = Modifier
&nbsp;            .applyQuackSize(
&nbsp;                width = width,
&nbsp;                height = height,
&nbsp;            )
&nbsp;            .drawUnderBarWithAnimation(
&nbsp;                width = QuackTextFieldUnderBarHeight,
&nbsp;                color = QuackTextFieldColors.underBarColor(
&nbsp;                    isError = isError,
&nbsp;                ),
&nbsp;            )
&nbsp;            .background(
&nbsp;                color = QuackColor.White.composeColor,
&nbsp;            )
&nbsp;            .padding(
&nbsp;                top = textStyle.calcQuackTextFieldTopPadding(),
&nbsp;                bottom = QuackTextFieldBottomPadding,
&nbsp;            ),
&nbsp;        value = text,
&nbsp;        onValueChange = onTextChanged,
&nbsp;        textStyle = composeTextStyle,
&nbsp;        keyboardOptions = keyboardOptions,
&nbsp;        keyboardActions = keyboardActions,
&nbsp;        // TextField is always single line
&nbsp;        // TextArea is always multi line
&nbsp;        singleLine = true,
&nbsp;        cursorBrush = quackTextFieldColors.textFieldCursorColor.toBrush(),
&nbsp;        decorationBox = { textField -&gt;
&nbsp;            QuackTextFieldDecorationBox(
&nbsp;                textField = textField,
&nbsp;                // placeholder is displayed when text is empty
&nbsp;                placeholderContent = when (isPlaceholder &amp;&amp; placeholderText != null) {
&nbsp;                    true -&gt; {
&nbsp;                        {
&nbsp;                            Text(
&nbsp;                                text = placeholderText,
&nbsp;                                style = composeTextStyle,
&nbsp;                                maxLines = 1,
&nbsp;                                softWrap = false,
&nbsp;                                overflow = TextOverflow.Ellipsis,
&nbsp;                            )
&nbsp;                        }
&nbsp;                    }
&nbsp;                    else -&gt; null
&nbsp;                },
&nbsp;                leadingContent = leadingContent,
&nbsp;                trailingContent = trailingContent,
&nbsp;            )
&nbsp;        },
&nbsp;    )
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * A decoration box used to draw decoration items for [QuackBasicTextField].
&nbsp; *
&nbsp; * @param textField BasicTextField to be treated as QuackTextField
&nbsp; * @param placeholderContent A placeholder content to display when the entered text is empty
&nbsp; * @param leadingContent The leading content of QuackTextField
&nbsp; * @param trailingContent The trailing content of QuackTextField
&nbsp; *
&nbsp; * @see QuackTextFieldDecorationContentHorizontalPadding
&nbsp; */
&nbsp;@Composable
&nbsp;private fun QuackTextFieldDecorationBox(
&nbsp;    textField: @Composable () -&gt; Unit,
&nbsp;    placeholderContent: (@Composable () -&gt; Unit)?,
&nbsp;    leadingContent: (@Composable () -&gt; Unit)?,
&nbsp;    trailingContent: (@Composable () -&gt; Unit)?,
&nbsp;) {
&nbsp;    Layout(
&nbsp;        content = {
&nbsp;            val padding = remember(
&nbsp;                key1 = leadingContent != null,
&nbsp;                key2 = trailingContent != null,
&nbsp;            ) {
&nbsp;                PaddingValues(
&nbsp;                    start = if (leadingContent != null) {
&nbsp;                        QuackTextFieldDecorationContentHorizontalPadding
&nbsp;                    } else {
&nbsp;                        0.dp
&nbsp;                    },
&nbsp;                    end = if (trailingContent != null) {
&nbsp;                        QuackTextFieldDecorationContentHorizontalPadding
&nbsp;                    } else {
&nbsp;                        0.dp
&nbsp;                    },
&nbsp;                )
&nbsp;            }
&nbsp;
&nbsp;            if (leadingContent != null) {
&nbsp;                Box(
&nbsp;                    modifier = Modifier.layoutId(
&nbsp;                        layoutId = QuackTextFieldLeadingContentLayoutId,
&nbsp;                    ),
&nbsp;                    contentAlignment = Alignment.Center,
&nbsp;                ) {
&nbsp;                    leadingContent()
&nbsp;                }
&nbsp;            }
&nbsp;            if (trailingContent != null) {
&nbsp;                Box(
&nbsp;                    modifier = Modifier.layoutId(
&nbsp;                        layoutId = QuackTextFieldTrailingContentLayoutId,
&nbsp;                    ),
&nbsp;                    contentAlignment = Alignment.Center,
&nbsp;                ) {
&nbsp;                    trailingContent()
&nbsp;                }
&nbsp;            }
&nbsp;            Box(
&nbsp;                modifier = Modifier
&nbsp;                    .layoutId(
&nbsp;                        layoutId = QuackTextFieldLayoutId,
&nbsp;                    )
&nbsp;                    .padding(
&nbsp;                        paddingValues = padding,
&nbsp;                    ),
&nbsp;                propagateMinConstraints = true,
&nbsp;            ) {
&nbsp;                textField()
&nbsp;            }
&nbsp;            if (placeholderContent != null) {
&nbsp;                Box(
&nbsp;                    modifier = Modifier
&nbsp;                        .layoutId(
&nbsp;                            layoutId = QuackTextFieldPlaceholderLayoutId,
&nbsp;                        )
&nbsp;                        .padding(
&nbsp;                            paddingValues = padding,
&nbsp;                        ),
&nbsp;                    propagateMinConstraints = true,
&nbsp;                ) {
&nbsp;                    placeholderContent()
&nbsp;                }
&nbsp;            }
&nbsp;        },
&nbsp;        measurePolicy = rememberQuackTextFieldMeasurePolicy(),
&nbsp;    )
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * [QuackCountableTextField]
&nbsp; *
&nbsp; * @param text
&nbsp; * @param onTextChanged
&nbsp; * @param textStyle
&nbsp; * @param placeholderText
&nbsp; * @param maxLength
&nbsp; */
&nbsp;@Composable
&nbsp;public fun QuackCountableTextField(
&nbsp;    text: String,
&nbsp;    onTextChanged: (text: String) -&gt; Unit,
&nbsp;    textStyle: QuackTextStyle = QuackTextStyle.Body1,
&nbsp;    placeholderText: String? = null,
&nbsp;    maxLength: Int,
&nbsp;) {
&nbsp;    QuackTextField(
&nbsp;        text = text,
&nbsp;        onTextChanged = { text -&gt;
&nbsp;            if (text.length &lt;= maxLength) {
&nbsp;                onTextChanged(text)
&nbsp;            }
&nbsp;        },
&nbsp;        textStyle = textStyle,
&nbsp;        placeholderText = placeholderText,
&nbsp;        trailingContent = {
&nbsp;            QuackBody2(
&nbsp;                text = &quot;${text.length} / $maxLength&quot;,
&nbsp;                color = QuackColor.Gray2,
&nbsp;            )
&nbsp;        },
&nbsp;    )
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-11-09 12:56</div>
</div>
</body>
</html>
